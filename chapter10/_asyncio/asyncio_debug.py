# 10.5.15 Отлкадка с помощью модуля asyncio
"""
В модуле asyncio предусмотрены полезные встроенные возможности отладки.
Например, цикл событий может использовать модуль logging (раздел 14.80)
для генерации сообщений о состоянии во время выполнения. Одни из этих
сообщений доступны, если в приложении были активизированы средства
протоколирования, другие могут быть включены непосредственным уведомлением цикла
о необходимости генерации дополнительных отладочных сообщений. Передав
методу set_debug() булево значение, можно указать, должна ли быть включена
отладка.

Поскольку приложения, созданные на основе модуля asyncio, крайне чувствительны
к сопрограммам, жадно потребляющим ресурсы и при этом не уступающим управления,
в цикл событий встроена поддержка, обеспечивающая обнаружение медленных функций
обратного вызова. Можно активизировать это средство, включив отладку, и управлять
определением того, что считать “медленным”, путем задания для свойства slow_callback_duration
длительности периода выполнения в секундах, в случае превышения которого должно
выводиться предупреждение.

Наконец, если приложение, использующее модуль asyncio, завершается без
выполнения надлежащих операций по закрытию сопрограмм и других ресурсов,
то такое поведение может указывать на наличие логической ошибки, препятствующей
нормальному выполнению кода. Включение уровня детализации сообщений ResourceWarning
обеспечит вывод соответствующих предупреждений призавершении работы программы.
"""
import argparse
import asyncio
import logging
import sys
import time
import warnings

parser = argparse.ArgumentParser('debugging asyncio')
parser.add_argument(
    '-v',
    dest='verbose',
    default=False,
    action='store_true'
)
args = parser.parse_args()
logging.basicConfig(
    level=logging.DEBUG,
    format='%(levelname)7s: %(message)s',
    stream=sys.stderr,
)
LOG = logging.getLogger('')


async def inner():
    LOG.info('inner starting')
    # Использовать блокирующую паузу для
    # имитации выполнения работы функцией
    time.sleep(0.1)
    LOG.info('inner completed')


async def outer(loop: 'asyncio.AbstractEventLoop'):
    LOG.info('outer starting')
    await asyncio.ensure_future(loop.create_task(inner()))
    LOG.info('outer completed')


if __name__ == '__main__':
    event_loop = asyncio.get_event_loop()
    if args.verbose:
        LOG.info('enaling debugging')

        # Включить отладку
        event_loop.set_debug(True)

        # В целях илюстрации установить очень низки порог для
        # "медленных" задач. По умолчанию он равен 0.1, или
        # 100 миллисекнд.
        event_loop.slow_callback_duration = 0.001

        # Сообщить обо всех ошибка управления асинхронными ресурсами
        warnings.simplefilter('always', ResourceWarning)
    LOG.info('entering event loop')
    event_loop.run_until_complete(outer(event_loop))
    """
    $ python3 asyncio_debug.py -v
    
    Включение режима отладки позволяет выявить наличие некоторых
    проблем в приложении. Например, несмотря на то что сопрограмма inner()
    завершается нормально, для этого ей потребовалось время, которое превышает
    предельное значение, установленное в свойстве slow_callback_duration.
    Кроме того, цикл событий не был надлежащим образом закрыт при завершениипрограммы.
    """