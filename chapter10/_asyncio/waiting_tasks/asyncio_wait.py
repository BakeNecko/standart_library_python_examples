# 10.5.6 Сочетание сопрограмм с управляющими конструкциями
"""
С линейным потоком управления между серией сопрограмм можно легко справиться
с помощью встроенного ключевого слово await. Использую инструменты, предоставляемые
модулем asyncio, можно создавать более сложные управляющие конструкции, которые
позволяют одной сопрограмме дожидаться завершения других сопрограмм, выполняющихся параллельно.

10.5.6.1 Ожидание завершения нескольких сопрограмм
Во многих случаях полезно разбить одну операцию на несколько частей, выполняющихся
по отедльности. Например, такой подход эффективен при загрузке данных из нескольких
удаленных источников или опросе удаленных программных интерфейсов. В ситуациях,
когда порядок выполнения не имеет значения, а количество операций может быть произвольным,
можно использовать функцию wait() для приостановки одной прогрммы до тех пор, пока не завершатся
другие операции, выполняющиемся в фоновом режиме.
"""
import asyncio


async def phase(i):
    print(f'in phase {i}')
    await asyncio.sleep(0.1 * i)
    print(f'done with pahse {i}')
    return f'phase {i} result'


async def main(num_phases):
    """
    asyncio.wait(...) Устарел с версии 3.8, планируется удаление в python 3.11
    asyncio.wait(...) также поддерживает аргемент timeout,
    Если функция wait() вызывается c аргументом timeout, то по истечении тайм-аута
    остаются только незавершенные операции.

    Остальные фоновые операции должны обрабатываться явным образом по
    нескольким причинам. Несмотря на то, что выполнение незавершенных задач
    приостанавливается, когда функция wait () выполняет возврат, оно будет
    возобновлено, как только управление вернется циклу событий. Без дополнительного
    вызова wait () выходные результаты задач никуда не попадут ~ задачи будут
    выполняться и потреблять ресурсы, но от этого не будет никакого результата.
    Кроме того, модуль asyncio вырабатывает предупреждения в тех случаях, когда
    при выходе из программы имеются незавершенные задачи. Эти предупреждения могут
    выводиться на экран, чтобы пользователь увидел их. Поэтому лучше всего: либо
    отменить остающиеся незавершенными фоновые операции, либо использовать
    функцию wait(), чтобы позволить им завершиться.
    """
    print('starting main')
    phases = [
        phase(i)
        for i in range(num_phases)
    ]
    print('waitig for phases to complete')
    completed, pending = await asyncio.wait(phases)
    result = [t.result() for t in completed]
    print('results: {!r}'.format(result))

if __name__ == '__main__':
    event_loop = asyncio.get_event_loop()
    try:
        event_loop.run_until_complete(main(5))
    finally:
        print('close event_loop')
        event_loop.close()
