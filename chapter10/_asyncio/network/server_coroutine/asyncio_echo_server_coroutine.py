# 10.5.9.1 Эхо-сервер
"""
Код эхо-сервера начинается с импорта модулей asyncio и logging (14.80)
и создания объекта цикла событий.
"""
import asyncio
import logging
import sys


async def echo(reader: 'asyncio.StreamReader', writer: 'asyncio.StreamWriter'):
    """
    Далее определяется сопрограмма, обеспечивающая взаимодействие с клиентом.
    Каждый раз, когда клиент запрашивает соединение, вызывается новый
    экзмепляр сопрогрммы; поэтому код в теле функции всегда взаимодействет
    только с одним клиентом за раз. Состоянием каждого экземпляра сопрограммы
    управляет среда времени выполнения Python, поэтому никакие дополнительные
    структуры данных, которые отслеживали бы отдельных клиентов в коде приложкния
    не требуются.
    Аргументами сопрограммы являются экземпляры StreamReader и StreamWriter,
    связанные с новым соединением. Как и в случае класса Transport, адрес
    клиента можно получить с помощью метода get_extra_info() объекта записи.
    """
    address = writer.get_extra_info('peername')
    _log = logging.getLogger('echo_{}_{}'.format(*address))
    _log.debug('connection accepted')

    while True:
        """
        Несмотря на то что сопрограмма вызывается, когда соединение уже установлено, 
        данные, которые должны быть прочитаны, к этому времени еще могут отсутствовать. 
        Чтобы избежать блокирования других операций при чтении данных, сопрограмма 
        использует ключевое слово await совместно c вызовом метода read(), 
        предоставляя циклу событий возможность выполнять другие задачи,
        пока не появятся данные для чтения.
        """
        data = await reader.read(128)
        if data:
            """
            Если клиент отправил данные, await возвращает их, и они могут быть отправлены 
            обратно клиенту путем передачи объекту записи. Исходящие данные могут 
            буферизоваться c помощью многократных вызовов метода write() c последующим 
            вызовом метода drain() для сброса результатов, оставшихся в буфере.
            Поскольку при сетевом вводе-выводе сброс буфера может блокировать другие
            операции, для возврата управления циклу событий вновь используется ключевое
            слово await, обеспечивающее мониторинг состояния объекта записи и его вызов
            при наличии данных, подлежащих отправке.
            """
            _log.debug('received {!r}'.format(data))
            writer.write(data)
            await writer.drain()
            _log.debug('sent {!r}'.format(data))
        else:
            """
            Если клиент не отправил никаких данных, то метод read() возвращает пустую
            байтовую строку, указывающую на то, что соединение закрывается. Сервер должен 
            закрыть сокет, после чего сопрограмма может выполнить возврат, 
            свидетельствующий о завершении ее выполнения.
            """
            log.debug('closing')
            writer.close()
            return


if __name__ == '__main__':
    """
    Запуск сервера осуществляется в два этапа. Во-первых, приложение информирует 
    цикл событий о том, что необходимо создать новый объект сервера c использованием 
    указанной сопрограммы, а также имени хоста и сокета, который будет прослушиваться. 
    Метод start_server() сам является сопрограммой, поэтому для фактического запуска 
    сервера результаты должны быть обработаны циклом событий.  В результате выполнения 
    этой сопрограммы создается экземпляр asyncio.Server, связанный c циклом событий.
    """
    SERVER_ADDRESS = ('localhost', 10000)
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(name)s: %(message)s',
        stream=sys.stderr,
    )
    log = logging.getLogger('main')

    event_loop = asyncio.get_event_loop()
    factory = asyncio.start_server(echo, *SERVER_ADDRESS)
    server = event_loop.run_until_complete(factory)
    log.debug('starting up on {} port {}'.format(*SERVER_ADDRESS))
    """
    На следующем этапе должен быть запущен цикл событий, который будет 
    обрабатывать события и клиентские запросы. Для длительно выполняющихся служб
    это проще всего обеспечить, вызвав метод run_forever(). В случае прекращения
    цикла событий из кода приложения или посредством отправки сигнала процессу 
    сервер можно закрыть для освобождения ресурсов, неиспользуемых сокетом.
    После этого можно закрыть цикл событий, чтобы завершить обработку других 
    сопрограмм перед выходом из программы
    """
    try:
        event_loop.run_forever()
    except KeyboardInterrupt:
        pass
    finally:
        log.debug('closing server')
        server.close()
        event_loop.run_until_complete(server.wait_closed())
        log.debug('closing event loop')
        event_loop.close()
