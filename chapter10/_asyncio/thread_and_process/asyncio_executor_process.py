# 10.5.14.2 Процессы
"""
Экземпляр ProcessPoolExecutor работает во многом аналогично экземпляру
ThreadPoolExecutor, создавая набор рабочих процессов вместо рабочих потоков.
Несмотря на то, что использование отдельных процессов требует большего количества
системных ресурсов, для интенсивных вычислительных операций целесообразно выполнять
отдельные задачи на каждом ядре CPU.
"""
from python_standart_lib.chapter10._asyncio.thread_and_process.asyncio_executor_thread import run_blocking_task
import asyncio
import concurrent.futures
import logging
import sys


if __name__ == '__main__':
    """
    Использование модуля logging (раздел 14.80) в сценарии asyncio_executor_thread.py 
    позволяет удобным образом проследить за тем, c каким потоком и какой функцией 
    связано каждое сообщение. Поскольку в каждом вызове blocks() используется свой 
    объект log, вывод отчетливо показывает, что одни и тс же потоки повторно 
    используются для вызова нескольких экземпляров функций c различными аргументами.
    """
    # Сконфигурировать протоколирование для отображения имени
    # процесса, из которого поступило сообщение
    logging.basicConfig(
        level=logging.INFO,
        format='PID %(process)5s %(name)18s: %(message)s',
        stream=sys.stderr,
    )

    # Создть ограниченный пул потоков
    executor = concurrent.futures.ProcessPoolExecutor(
        max_workers=3,
    )

    event_loop = asyncio.get_event_loop()
    try:
        event_loop.run_until_complete(
            run_blocking_task(executor)
        )
    finally:
        event_loop.close()
    """
    Единственное изменение, которое потребовалось внести для перехода от потоков 
    к процессам, заключается в создании объекта-исполнителя другого типа.
    Кроме того, в этом примере в строке формата вместо имени потока используется
    идентификатор процесса, чтобы продемонстрировать, что задачи действительно
    выполняются в отдельных процессах.
    """