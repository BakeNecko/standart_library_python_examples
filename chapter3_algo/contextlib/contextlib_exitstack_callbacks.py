# 3.4.7.2
# Использование произвольных функций обратного вызова в контекстах
# Класс ExitStack также поддерживает использование произвольных функций
# обратного вызова для закрытия контекста, что упрощает выполнение завершающих
# операций по освобождению ресурсов, которые не контролируются менеджером контекста.
import contextlib


def callback(*args, **kwargs):
    print(f'closing callback({args}, {kwargs})')


with contextlib.ExitStack() as stack:
    stack.callback(callback, 'arg1', 'arg2')
    stack.callback(callback, arg3='val3')

# Как и в случае методов__ exit__ () полных менеджеров контекста, функции
# обратного вызова вызываются в обратном порядке по отношению к порядку их регистрации.

# Функции обратного вызова вызываются независимо от того, возникла ли
# ошибка, и не получают никакой информации об ошибке, если она возникает.
# Возвращаемое ими значение игнорируется.

try:
    with contextlib.ExitStack() as stack:
        stack.callback(callback, 'arg1', 'arg2')
        stack.callback(callback, arg3='arg3')
        raise RuntimeError('thrown error')
except RuntimeError as err:
    print('ERROR: {}'.format(err))

# Функции обратного вызова обеспечивают удобный способ четкого определения
# логики освобождения ресурсов без дополнительных накладных расходов,
# связанных c созданием нового класса менеджеров контекста. Для улучшения читаемости
# кода эту логику можно инкапсулировать во встраиваемую функцию c ис­
# пользованием функции callback () в качестве декоратора.

with contextlib.ExitStack() as stack:
    @stack.callback
    def inline_cleanup():
        print('inline_cleanup()')
        print('local_resource = {!r}'.format(local_resource))
    local_resource = 'resource created in context'
    print('within the context')

# Не существует способов передачи аргументов функциям, зарегистрированным
# c помощью функции callback () в форме декоратора. Однако в случае использования
# встраиваемой функции правила областей видимости предоставляют ей доступ
# к переменным, определенным в вызывающем коде
