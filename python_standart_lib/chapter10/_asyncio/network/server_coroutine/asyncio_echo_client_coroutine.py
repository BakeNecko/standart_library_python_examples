# 10.5.9.2 Эхо-клиент
"""
Создание клиента с использоавнием сопрограммы очень напоминает создание
сервера. Код клиента также начинается с испорта модулей asyncio и logging
(14.80) с последующим созданием объекта цикла событий.
"""
import asyncio
import logging
import sys


async def echo_client(address, messages):
    """
    Сопрограмма echo_client получает аргументы, содержащие информацию о
    расположении сервера и отправляемых сообщениях. Сопрограмма вызывается
    при запуске задачи, но в условиях отсутствия соединения, с которым можно работать.
    Поэтому первым шагом является установление клиентом собственного соединения.
    Чтобы избежать блокирования других операций во время выполнения сопрограммы
    open_connection(), используется ключевое слово await.
    """
    log = logging.getLogger('echo_client')
    log.debug('connection to {} port {}'.format(*address))
    reader, writer = await asyncio.open_connection(*address)
    """
    Сопрограмма open_connection() возвращает экземпляры StreamReader и StreamWriter,
    связанные с новым сокетом. Слеющим шагом является отправка данных на севрер с помощью
    лбъекта записи. Как и в случае севера, объект записи будет буферизировать исходящие 
    данные до тех пор, пока сокет не перейдет в состояние готовности ли пока метод drain() 
    не будет использован для сброса результатов, оставшихся в буфере. Посколкьо при сетевом
    вводе-выводе сброс буфера может блокировать другие операции, для возврата управления 
    циклу событий вновь используется ключевое слово await, обеспечивающие мониторинг состояния
    объекта записи и его вызовов при наличии данных, подлежищих отправке.
    """
    # Здесь можно было бы использовать метод
    # transport.writelines(), но это затруднило бы
    # представление кадой части отправляемого сообщения
    for msg in messages:
        writer.write(msg)
        log.debug('sending {!r}'.format(msg))
    if writer.can_write_eof():
        writer.write_eof()
    await writer.drain()
    """
    Далее клиент получает ответ сервера, пытаясь читать данные до тех пор, пока 
    будет что читать. Чтобы избежать блокировки на одном отдельном вызове 
    метода read(), управление возвращается циклу событий с помощью ключевого
    слова await. Отправленные сервером данные протоколируются. Если сервер не 
    отправил никаких данных, то метод read() возвращает пустую байтовую строку,
    указывающиую на то, что соединение закрывается. Клиент должен сначала закрыть
    сокет, а затем выполнить возврат, свидетельствующий о завершении выполнения.
    """
    log.debug('waiting for response')
    while True:
        data = await reader.read(128)
        if data:
            log.debug('received {!r}'.format(data))
        else:
            log.debug('closing')
            writer.close()
            return


if __name__ == '__main__':
    """
    Клиент запускается посредством вызова цикла событий c сопрограммой для
    создания клиента. Использование метода run_until_complete() для этой цели
    позволяет избежать создания бесконечного цикла в клиентской программе. 
    В отличие от примера, в котором использовался класс протокола, создавать 
    отдельный фьючерс, сигнализирующий о завершении работы сопрограммы, 
    не требуется, поскольку функция echo_client() содержит всю клиентскую 
    логику и не возвращает управление до тех пор, пока не получит ответ 
    и не закроет соединение c сервером
    """

    MESSAGES = [
        b'This is the message. ',
        b'It will be sent ',
        b'in parts.'
    ]
    SERVER_ADDRESS = ('localhost', 10000)

    logging.basicConfig(
        level=logging.DEBUG,
        format='%(name)s: %(message)s',
        stream=sys.stderr,
    )

    log = logging.getLogger('main')
    event_loop = asyncio.get_event_loop()
    try:
        event_loop.run_until_complete(
            echo_client(SERVER_ADDRESS, MESSAGES)
        )
    finally:
        log.debug('closing event loop')
        event_loop.close()
    """
    Несмотря на то что клиент отправляет сообщения по отдельности, при первых 
    двух запусках клиента сервер получает одно длинное сообщение и отсылает
    по обратно клиенту. При последующих запусках клиента результаты могут 
    выглядеть несколько иначе, в зависимости от загруженности сети, а также от того,
    сбрасываются ли сетевые буферы до того, как будут подготовлены все данные
    """